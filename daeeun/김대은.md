## 23.01.16
- 채팅 필터링 (네이버 오픈소스)
- 사연자가 방에 참여했는지 안했는지를 리스트로 확인 가능하게(내가 원하는 사람의 실시간 connection정보) - session서버 필요 ⇒ 접속중인지 알 수 있는 API 필요 (call by call은 불가)
    - 슈퍼챗기능(사연자) 채팅화면에 고정시키는 것………..!?
- 접속자 정보를 다 알고 있는 것이 중요
- 고정시간을 어떻게 관리할 것인가. 정해진 편성표 기준으로 추천알고리즘을 짜기 때문에 경고 보다 자율적인 규제가 가능할듯.
- 추천알고리즘
    - 로그인 이후에 메인화면에서 추천알고리즘을 보여주게 된다면 낭비되는 리소스가 많을 것. (효율적인 방법을 고려해보기)
    - 최대 접속자 채널을 어떻게 저장할것인지.
    - 구독자 수 sorting list == 세션에 있는 리스트 해서 출력
- 실시간 구독자 수 기능
    - 캐시서버를 사용해야함.
    - spring캐시로 사용 안됨
    - 로그 DB필요
    - 실시간으로 갱신을 할 건지, 아니면 하루에 한 번만 갱신을 할 건지 고민
    - 전체 유저 대비 DJ의 비율에 대해 시장조사(스푼라디오, 유튜브 …)
    - DJ 누구를 팔로우 언제 > DJ 누구를 팔로우 해제 언제 (log data)
    - 최초 시점을 DJ 개설할 때 구독자 수를 가져올 수 있음.(마이페이지에 방송정보를 입력할 때가 최초 시점)
    - DB에 적혀있는 log는 복원용,
    - 누가 팔로우 하면 버퍼 +1되는 api호출
    - 오차 감안 ~~~!!!!
    - 하루에 한번은 DB랑 맞는지 확인하고싶어 !!!!! (사람이 가장 없는 시간에 팔로우 log 정보를 분석해서 정확한 count 뽑아온다)
    - 이후 overwrite.(의 반복~~)
    - 일주일동안 아무도 나를 팔로우/팔로잉 하지 않을 경우 삭제 > 삭제하기 전에 백업table  > 그냥 프로필DB 에 저장 (해당 DB에 하루한번씩 overwrite)
    - 배치JOB , JOB Queue
- 전화번호 없어도 됩니다.
- 관리자 페이지 없어도 될듯 (Super계정 필요없음)
- 카테고리 알아서(meta table로 빼세요)
- reg_date 저장
- 개인의 편성표 ..
- sorting은 db에서 하지마라
- order by,like,delete는 없음
- 검색은 어떻게 검색할것인지, 뭘 검색할것인지 고려해볼것
- S22크기에 맞춰서 모바일 화면 하나 더 만드는걸로.

* Jira 정리
  * 한 주 시작이므로 계획을 짜고 시작했습니다.

## 23.01.17 
- [기능 명세서](https://www.notion.so/e5110b1024f04ad996daf0832b1a1fe6?v=ee53a0261e2f4789a8d6da4fccd5f1ae)
- [ERD, 데이터 설계](https://www.notion.so/ERD-2bcf4a10b26e4d4595cfda4358d0f1bd)

## 23.01.18 
```
        생성
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        //code
        EntityTransaction tx = em.getTransaction();
        tx.begin();

        try {
            Member member = new Member();
            member.setId(2L);
            member.setName("HelloB");
            // 실행이 안되는 이유 트랜젝션을 안해주었기 때문에!!

            em.persist(member); // 저장하는 것
            tx.commit();
        }catch (Exception e){
            tx.rollback();
        }finally {
            em.close();
        }
        emf.close();
```

```
        수정
        Member findMember = em.find(Member.class, 1L);
				findMember.setName("HelloJPA");

        tx.commit();
```

```
        삭제
        Member findMember = em.find(Member.class, 1L);
        System.out.println("findMember.id = " + findMember.getId());
        System.out.println("findMember.name = " + findMember.getName());

        tx.commit();
```
```
        조회
        Member findMember = em.find(Member.class, 1L);
        em.remove(findMember);

        tx.commit();
```

```
package hellojpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;
import java.util.List;

public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        //code
        EntityTransaction tx = em.getTransaction();
        tx.begin();

        try {
            List<Member> result = em.createQuery( "select m from Member as m", Member.class)
                    .setFirstResult(5)
                    .setMaxResults(8)
                    .getResultList();

            for (Member member : result){
                System.out.println("member.name = " + member.getName());
            }
            tx.commit();
        }catch (Exception e){
            tx.rollback();
        }finally {
            em.close();
        }
        emf.close();
    }
}
```

## 23.01.19
- 영속성 컨텍스트
엔티티를 영구 저장하는 환경 : DB에 저장하는 것이 아니라 엔티티를 영속성 컨텍스트에 관리되는 상태
```
- 비영속
Member member = new Member();
member.setId(1L);
member.setName("HelloJPA"); 
-----------------------------
- 영속
em.persist(member);
DB는 커밋을 해야 저장됩니다!!
```
- 이점 
    - 1차 캐시
    ```
    Member findMember1 = em.find(Member.class, 101L);
    Member findMember2 = em.find(Member.class, 101L);
    ```
---
- ERD Cloud 수정
![image.png](./image.png)

## 23.01.20
- # FRONT

1. CSR로 제작하면 SEO(검색했을 때 노출되는 빈도)가 잘 안됨.
    1. SSR+CSR로 만들어보는게 좋을 것 같다. (잘 알아볼 것)
2. 마이페이지
    1. DJ
        1. ONAIR를 **방송중일때만 컬러**가 나오고, 방송중이 아닐때에는 컬러 안나오게,
        2. 혹은 방송중일때는 **ONAIR가 깜빡거리는 애니메이션**을 부여하는 것도 좋을것 같다.
        3. 블랙리스트
            1. 블랙리스트 버튼을 최상단에 두어야할까..? 최상단에 있을 때 기분이 좋지 않을 것 같음 ⇒ **아래쪽이나 잘 안보이는 곳에 배치**해보는 것을 생각해보자(그리고, 블랙리스트 너무 해맑나..ㅎㅎ)
            2. 유튜브방송 ⇒ 채팅차단기능 강퇴기능 .. 참고 ! 채팅차단/강퇴 따로 구분해서 넣는게 좋을 듯
        4. 방송국정보
            1. 공지에서 **스티커** 제공해주는 것도 좋은 듯(유튜브 채팅방 아래쪽에 있는 스티커처럼, 대신 스티커는 공지의 글자 앞-뒤에 고정)
            2. 방송국정보 수정 editer 폼이 방송국 정보를 보여주는 폼과 같게하자.
        5. 사연함
            1. 사연 작성시 textbox **글자 수 제한**
            2. 하단에 **글자수제한 현황 노출**시키기 100/500
            3. 수정하기 전 내용을 보여주는란 디자인 하기(수정) ⇒ 단순 input박스보다 디자인 된 box혹은 디자인 된 화면을 보여주자.
            4. 개인이 작성한 사연은 방송을 하고 있을 때 **수정이 불가**하게. 수정버튼을 못누르게 막는 방법을 사용하는게 좋을 것 같다.(BLIND방식이라던가)
            5. 사연함 **사연날짜+시+분**을 보여주는 쪽이 좋을 것 같음(hover했을 때 시분초 보이게 해도 좋을 것 같고)
            6. 삭제하기보다 가리기.. 가려져있는 것들 보기(실시간으로 삭제보다는 가리고 싶을것 같음)
            7. 사연함에서도 블랙리스트 추가해야하지 않을까,
3. 목록토글
    1. 구독중인 방송국 목록을 투명하게 하는 것도 고려해봅시다
    2. 구독중인 방송국 중, **실시간일 경우** 빨간색으로 고정해놓는 것이 아니라, 깜빡거리는 **애니메이션을 적용**시켜보자(정적인 것 보다 동적으로 애니메이션을 주는 것이 좋을 것 같음)
4. 편성표
    1. 편성표 UI좋음 ⇒ 슬라이딩효과로 오른쪽 왼쪽으로 이동하되, o o o o o 옮기는 식으로 보여주면 좋을 것 같음(UI 확인)(**캐러셀** 효과처럼)
    2. 편성표 수정하는 페이지 ⇒ 더 **직관적**으로 바꿔보자 ..~!!!
    3. +) 검색기능 
    4. 모달로 띄우는 것도 더 직관적일 것 같음.
    5. 편성표 세팅화면에서 썸네일을 고르는 것도 중요한 요소가 될것같다(수정필요)
5. 방송국명=제목으로 해도 될거같음 (라디오는 굳이 변경하는 일이 없음)
6. 방송화면
    1. 채팅차단 기능, 강퇴기능을 고려해보자!
    2. 채팅/화면을 별개로 관리해야한다.
    3. 뱃지 디자인해야함.ㅎ
    4. 채팅할 때 닉네임 앞에 뱃지를 보여준다
    5. 강퇴버튼은 수정이 필요하다. 잘못누르면 실수로 강퇴할 수 있을 것 같다.
    6. 하지만 그렇다고 모달을 사용하는 것은 DJ에게 너무 귀찮을 일. 고려하자.
    7. DJ가 강퇴를 할 때 동선을 조금 더 생각해보자. 근데 WebRTC 화면이 어떻게 나올지 몰라서.. 설에 AWS에 올려서 구현해보기.
    8. 방송시작버튼.. 어디있지?
    9. 방송 시작하면 대기실도 있어야할듯 (openvidu에서 제공하지만 어떻게할건지)
    10. 음성변조, 화면 블러 기능
7. 전체적으로 좋지만, 동적인 애니메이션을 부여할 수 있는 부분에서는 동적인 애니메이션을 부여했으면 좋곘음. 또, 동적인 애니메이션이 너무 지저분하거나 정신없어보이지 않았으면 좋겠다. (**STATIC한것보단 DYMANIC한 효과 많이쓰는 추세**)

!! 청취자 목록 보여주는거 안넣음..

청취자 목록 보여주는 페이지 만들어야함.

!! 방 만드는 페이지 만들어야함 … 

# BACK

1. user
    1. **닉네임**은 변경할 수 있는 값이니까 -> **change count x 누가 언제 변경했다 로깅**만 하면됩니다.
        1. 테이블 분리해서 로깅하는 것이 효과적이다.
        2. 체킹을 하는 것은 로깅을 하는 것!!!!!
        3. 기본적으로 로깅하는 것
2. 회원가입 로그인, 카카오 로그인하면? -> 계정이 2개 ? 합쳐질 것인가 -> 인증 ?
원래는 di -> 본인인증 키, 우리는 di 값을 못가지고 와서 합칠 수 없다
그럼 우째 하는 것인가 ?? 성별이나 그러한 것은 옵션으로 넣어서 베네핏을 줌..
    1. 러프하게 물어볼 수 있다. (10대~, 20대~)
    2. 본인인증 외에는 신뢰성 낮음
    3. 우리가 신뢰성을 높이려면 본인인증(파이프라인) 했다고 패스 (즉, 프로토 타입)
    4. 강제로 해야한다고 될 것이다.
    내가 회원가입 해서 로그인, 카카오 로그인, 카카오로 로그인 한 애가 회원가입 한 애네 ?
    5. 너 예전에 가입했었어 ~ 매핑을 해줘서 둘 다 상관없게 하거나 ...(그렇게까지 해야하나?)
    
    **서드파티 인증에 본인인증 유저별 나이대를 알아야 하는 것이면 선호하는 연령대 그쪽으로 추천으로 유도
    -> 서드파티 키 들어가야합니다. 채널 키 (인증) -> 업데이트되는 컬럼키가 없어야 한다!!!**
    
3. user_function
    - has_station 필요가 없다
    - **playlist : json -> 변경 이력을 저장을 안해도 되는가 -> 계속 오버라이팅? -> nosql로 하는 것 ( 계속적인 변경하는 것이니까 )**
    ex ) -> 박찬국의 첫번째 시퀀스 완료 -> 수정하면 두번째 .. 세번째 .. 꺼내올 때는 제일 위에껄 하는 것 -> 보통은 이런 식으로 하는 것입니다.( 스탬프 찍는 형식, 무조건 rdb에 써야하는 값 )
4. log db 생성시점과 종료시점을 나누었는데 중복이 많아서 합쳤다.
broadcast_id
... 로깅을 많이 할까 ?
노말라이제이션 boardcast_id 로 중복되는 값을 저장하고 start, end테이블만 따로 저장?
start가 있으면 항상 end 가 있어 시스템이 보장을 한다면
첫번째 들어오는 값은 start, 나중은 end
**start_is_on_time, end_is_on_time**
5. **사연함은 캐시**로 해서 넣었다가 뺐다가 ? 캐시에선 삭제를 해도 되니까
**사연함 리스트는 rdb가 아니라 캐시**에 의존한다. ->
**db는 백업용**( 다 사라졌을 경우에 다시 다 그려줍니다. )
-> **ha** (고가용성의 포인트!!)
-> 캐시가 반응이 없어도 db에서 댕기면 되니까

## 23.01.25
- [API 명세](https://www.notion.so/BE-API-3e7de83c38e4478c89505816df0a42d7)

## 23.01.26
- jpa 학습
- mysql과 jpa 연동 test
```
# MySQL8 설정
spring.datasource.url=jdbc:mysql://localhost:3306/jpa?useSSL=false&characterEncoding=UTF-8&serverTimezone=UTC
spring.datasource.username=유저아이디
spring.datasource.password=비밀번호
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 콘솔에 SQL 출력 여부
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
spring.jpa.database=mysql
spring.jpa.hibernate.ddl-auto=none
spring.jpa.hibernate.naming.strategy=org.hibernate.cfg.ImprovedNamingStrategy
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
spring.jpa.generate-ddl=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true
# hibernate 설정
```

```
plugins {
    id 'java'
    id 'org.springframework.boot' version '2.7.8'
    id 'io.spring.dependency-management' version '1.0.15.RELEASE'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation group: 'org.javassist', name: 'javassist', version: '3.15.0-GA'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    implementation 'junit:junit:4.13.1'

    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'com.mysql:mysql-connector-j'

    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    //JUnit4 추가
    testImplementation("org.junit.vintage:junit-vintage-engine") {
        exclude group: "org.hamcrest", module: "hamcrest-core"
    }
}

tasks.named('test') {
    useJUnitPlatform()
}
```
---
```
package com.example.test.repository;

import com.example.test.domain.Member;
import org.assertj.core.api.Assertions;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.Rollback;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;
@RunWith(SpringRunner.class)
@SpringBootTest
public class MemberRepositoryTest {

    @Autowired
    MemberRepository memberRepository;

    @Test
    @Transactional
    @Rollback(false)
    public void testMember(){
        Member member = new Member();
        member.setUsername("memberA");
        Long saveId = memberRepository.save(member);

        Member findMember = memberRepository.find(saveId);

        System.out.println(findMember);
        Assertions.assertThat(findMember.getId()).isEqualTo(member.getId());
        Assertions.assertThat(findMember.getUsername()).isEqualTo(member.getUsername());
        Assertions.assertThat(findMember).isEqualTo(member);

    }
}

```

## 23.01.26
- jpa 학습
- mysql과 jpa 연동 test
```
package com.ssafy.bora.domain;

import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.Type;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import java.util.List;
import java.util.Map;


@Entity
@Getter
@Setter
public class User {

    @Id
    @GeneratedValue
    @Column(length = 16)
    private String id;

    @Column(length = 10)
    private String name;

    @Column(name = "nick_name", length = 10)
    private String nickName;

    @Type(type = "json")
    @Column(columnDefinition = "json")
    private List<Playlist>;

    @Column(name = "is_delete", length = 1)
    private Byte isDelete;

    @Column(length = 1)
    private Byte status;
}
```

```
package com.ssafy.bora.dao;

import com.ssafy.bora.domain.User;
import org.assertj.core.api.Assertions;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.Rollback;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import static org.junit.Assert.*;

@RunWith(SpringRunner.class)
@SpringBootTest
public class UserRepositoryTest {
    @Autowired
    UserRepository userRepository;

    @Test
    @Transactional
    @Rollback(false)
    public void testUser(){
        User user = new User();
        user.setName("memberA");
        String savedId = userRepository.save(user);

        User findMember = userRepository.find(savedId);

        Assertions.assertThat(findMember.getId()).isEqualTo(user.getId());
        Assertions.assertThat(findMember.getName()).isEqualTo(user.getName());
        // jpa 엔티티 동일성 보장
        Assertions.assertThat(findMember).isEqualTo(user);
    }
}
```

## 23.01.30
# EC2 빌드

# Maria DB

ssh -i /c/Users/SSAFY/Downloads/pem ubuntu@pem파일.p.ssafy.io

yes

sudo mysql

exit

# test build

(`@SpringBootTest` 주석처리 후) 

chmod +x gradlew

sudo ./gradlew build

## 23.01.31
# EC2 빌드 + WebRTC 공부

## 23.02.01
- (CI/CD 학습) [https://encouraging-snap-3c6.notion.site/EC2-b7b91b00aae34e22813035dd0ce69768]
- (WebRTC 학습) [https://encouraging-snap-3c6.notion.site/ce9a47ea5c8243d6a6a24706bde0e973]
